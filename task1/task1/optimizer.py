import numpy as np
from qiskit.circuit import QuantumCircuit
from qiskit import Aer, execute
from qiskit.providers.aer import AerProvider
from qiskit.quantum_info import Statevector

def metric(a: np.ndarray, b: np.ndarray) -> np.float_:
    """The metric to minimize (i.e. the sum of the squares of the components of a - b)

    Args:
        a: a vector
        b: another vector
    
    Returns:
        the metric value
    """
    return np.linalg.norm(a - b)**2

def objective_function(params: np.ndarray, circuit: QuantumCircuit, objective_vector: Statevector, backend: AerProvider) -> np.float_:
    """The function to be passed to scipy.optimize.minimize for it to minimize it

    The function binds the current set of parameters to the circuit, computes the resulting statevector and
    returns the metric with respect to the goal state

    Args:
        params: the current set of gate parameters
        circuit: the quantum circuit to use
        objective_vector: the statevector we want to generate with the circuit
        backed: a backend to execute the circuit in. Should be a statevector_simulator provider,
                since we need to get the full state probabilty amplitudes
    
    Returns:
        the metric value of the statevector generated by the circuit with the current set of parameters
        with respect to the goal statevector
    """
    # QuantumCircuit.parameters is a set, so the order is not guaranteed
    # We sort them using their names to keep an order
    parameters = list(circuit.parameters) 
    parameters.sort(key=lambda x: x.name)
    bound_parameters = dict(zip(parameters, params))

    # We need optimization_level=0 because otherwise the compiler may sometimes
    # introduce global phases compromising the metric convergence
    job = execute(circuit, backend, optimization_level=0, shots=1, parameter_binds=[bound_parameters])
    statevector = job.result().get_statevector()
    
    return metric(statevector, objective_vector.data)
